301_Remove_Invalid_Parentheses


题目大意
Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

Note: The input string may contain letters other than the parentheses ( and ).

解决方案
题目翻译：给出一个括号序列，删除最少数目的括号，使得序列“合法”（左右括号能匹配）


先搞清楚2个重要的性质：
假设串s合法

1. 产生非法串"s)"的所有合法串的算法是如下，
if(s[j] == ch && s[j-1]!= ch))
并且这个算法产生的串不会重复
证明：
这个算法能产生所有串是显然的，因为只需要删1个，也就是只需要挑1个，而且，若干个相邻的')'只能删除一个，否则明显重复了
下面证明
如果两个')'不相邻，那么删除左边那个和删除右边')'那个所产生的串一定不相等：
想象一下，
x..y)A(m...n)k...
删除第1个')'得到：
x..yA(m...n)k...
删除第2个')'得到：
x..y)A(m...nk...

对这两个串做对齐比较，可知A的第1个字符是')'、A的第2个字符是')'、A的第3个字符是')'。。。A全是')'
但是就算A全是右括号，还是匹配失败了，因为A最后一个字符没法跟'('匹配上

2. A)B(C)D)E，其中
删除前两个')'和删除后两个')'所产生的串一定不相等
AB(C)DE
A)B(CDE
或者
AB(CD)E
也就是上面这两个串不相等
假如相等，看到')'==B[0], B[0]==B[1], B[1]=B[2]...
说明B全是')'但是这样任然失败，因为B的最后一个字符要和'('比较
把第三个串拿来看也是一样的




以输入"(())())())"为例
深搜：
首先发现s[6]非法
因此依次求解
"(()())())" (删除[2])
    依次求解
    "((())())" (删除[2])
    "(()()())" (删除[4])
    "(()())()" (删除[7])

"(())()())" (删除[5])
    依次求解
    注意：上一次删除了5，所以这个删除2的就不做了，直接从5开始"(()()())" (删除[2]) 
    "(())(())" (删除[5])
    "(())()()" (删除[7])

因此得到的解是：(看看解的顺序，也能加深理解)
((())())
(()()())
(()())()
(())(())
(())()()


广搜：
广搜的解也是：(解的排列顺序和深搜也一样)
((())())
(()()())
(()())()
(())(())
(())()()
但是广搜获得解的过程略有差异。前三个解有同一个“父亲”，在深搜里根据这个父亲，立马去深搜，得到前三个解，然后再得到第二个“父亲”，得到后两个解
广搜是先将两个“父亲”入队，然后最后再依次求出5个解




有深搜和广搜两种解法：
深搜参考了
http://lib.csdn.net/article/datastructure/18481
上面这两条性质都是为了理解这个网页的深搜解法才想出来的。深搜的做法是：
从左到右，找到第一个导致非法的')'，然后以它为终点，用性质1对左侧的')'进行删除，就产生了从左边到当前位置的一个合法串，假设是从s1到sm，称之为m串(有很多种，由性质1设计出的算法能保证恰好产生所有m串)
然后递归调用dfs，并且递归调用的时候要当前删除的位置信息的参数，下次找能删除的')'时要从这个位置右边开始。
第2个合法m串就是删除第二个')'产生的，因此这两个m串所产生的结果绝对不会重合（在性质2中被证明出来的）
ok，这样就匹配除了所有')'，再对称地处理出'('，就完成了。

完成了深搜解法，理解了原理之后就容易写广搜解法了
从左到右，找到第一个导致非法的')'，然后以它为终点，用性质1对左侧的')'进行删除，就产生了从左边到当前位置的一个合法串，
与深搜不同的是，深搜找到一个当前位置的合法串，立即递归调用，去和右侧剩余未处理的串组合起来求解。
而广搜只能先把所有备选解扔进到队列里，然后从队列里选备选解，再处理。





样例
Examples:
"()())()" -> ["()()()", "(())()"]
"(a)())()" -> ["(a)()()", "(a())()"]
")(" -> [""]